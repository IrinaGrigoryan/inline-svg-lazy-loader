!function (t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.inlineSvgLazyLoader = e() : t.inlineSvgLazyLoader = e()
}(self, (() => (() => {
    "use strict";
    var t = {
        d: (e, s) => {
            for (var r in s) t.o(s, r) && !t.o(e, r) && Object.defineProperty(e, r, {enumerable: !0, get: s[r]})
        }, o: (t, e) => Object.prototype.hasOwnProperty.call(t, e), r: t => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t, "__esModule", {value: !0})
        }
    }, e = {};
    t.r(e), t.d(e, {default: () => s});

    class s {
        constructor() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "js-lazy-inline-svg",
                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            this.selector = t, this.options = e || {loadingClass: "js-svg-loading"}, this.observerOptions = {threshold: [.1]}, this.init()
        }

        init() {
            this.elements = [...document.querySelectorAll(`.${this.selector}`)], this.elements.length && this.elements.forEach((t => {
                this.addInlineSvgObserver(t)
            }))
        }

        addInlineSvgObserver(t) {
            const e = new IntersectionObserver((t => {
                t.forEach((t => {
                    const {isIntersecting: s, target: r} = t;
                    s && (this.getSvg(r), e.unobserve(r))
                }))
            }), this.observerOptions);
            e.observe(t)
        }

        async getSvg(t) {
            const {src: e} = t.dataset, {loadingClass: s} = this.options;
            t.classList.add(s);
            try {
                const s = await fetch(e);
                if (s.ok) {
                    const e = await s.text();
                    this.replaceImgWithSvg(e, t)
                }
            } catch (t) {
                console.error(t)
            }
        }

        replaceImgWithSvg(t, e) {
            const s = this.parseSvgStringToHtml(t);
            this.removeAttrs(s, e), this.removeScripts(s, e), this.addAttrs(s, e), this.setSvgSize(s, e), e.parentNode && e.parentNode.replaceChild(s, e)
        }

        parseSvgStringToHtml(t) {
            return (new DOMParser).parseFromString(t, "text/html").querySelector("svg")
        }

        removeAttrs(t, e) {
            const {removeAttrs: s} = e.dataset;
            s && s.split(",").forEach((e => {
                const s = e.trim();
                t.removeAttribute(s)
            }))
        }

        addAttrs(t, e) {
            const {addAttrs: s} = e.dataset;
            if (s) {
                const e = /([\w\d\-\s*]+):\s*[\w\d\-\s*]+/g;
                s.match(e).forEach((e => {
                    const [s, r] = e.split(":");
                    t.setAttribute(s.trim(), r.trim())
                }))
            }
        }

        setSvgSize(t, e) {
            const {setSvgSize: s} = e.dataset;
            s && (t.setAttribute("width", e.width), t.setAttribute("height", e.height))
        }

        removeScripts(t, e) {
            const {removeScripts: s} = e.dataset;
            if (s) {
                const e = t.querySelectorAll("script"), s = t.getAttributeNames();
                if (e.forEach((t => {
                    t.remove()
                })), s) {
                    const e = /^on\w*/i;
                    s.forEach((s => {
                        s.match(e) && t.removeAttribute(s)
                    }))
                }
            }
        }
    }

    return "undefined" != typeof window && (window.InlineSvgLazyLoader = s), e
})()));
